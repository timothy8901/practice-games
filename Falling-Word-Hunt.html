<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WordFall</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation; /* Prevents double-tap zoom on mobile */
        }
        .letter-cell {
            transition: transform 0.3s ease-out, background-color 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .letter-cell.selected {
            background-color: #3b82f6; /* blue-500 */
            color: white;
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .letter-cell.highlight-best {
            background-color: #facc15; /* yellow-400 */
            color: #1e293b; /* slate-800 */
            transform: scale(1.1);
        }
        .letter-cell.clearing {
            transform: scale(0);
        }
        #game-board {
            display: grid;
            grid-template-columns: repeat(8, minmax(0, 1fr));
            grid-template-rows: repeat(8, minmax(0, 1fr));
            gap: 4px; /* A smaller gap */
            aspect-ratio: 1 / 1;
            max-width: 90vw;
            max-height: 90vh;
        }
        @media (min-width: 768px) {
            #game-board {
                gap: 8px;
            }
        }
        .modal {
            display: none;
        }
        .modal.active {
            display: flex;
        }
    </style>
</head>
<body class="bg-slate-100 text-slate-800 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-2xl mx-auto">
        <header class="text-center mb-4">
            <h1 class="text-4xl md:text-5xl font-bold text-slate-700">WordFall</h1>
            <p class="text-slate-500">Find words, clear letters, score high!</p>
        </header>

        <main id="game-container" class="bg-white p-4 sm:p-6 rounded-2xl shadow-lg">
            <!-- Game Info Bar -->
            <div class="flex justify-between items-center mb-4 text-center">
                <div>
                    <span class="text-sm text-slate-500 block">SCORE</span>
                    <span id="score" class="text-2xl font-bold text-blue-600">0</span>
                </div>
                <div class="flex-grow mx-4 px-2 py-2 bg-slate-100 rounded-lg h-12 flex items-center justify-center">
                    <span id="current-word" class="text-xl font-semibold tracking-widest text-slate-600 truncate min-h-[28px]">-</span>
                </div>
                <div>
                     <span class="text-sm text-slate-500 block">WORDS</span>
                    <span id="word-count" class="text-2xl font-bold text-blue-600">0</span>
                </div>
            </div>

            <!-- Game Board -->
            <div id="game-board" class="bg-slate-200 rounded-lg p-2 select-none">
                <!-- Letter cells will be generated by JavaScript -->
            </div>

            <!-- Controls -->
            <div class="grid grid-cols-2 gap-4 mt-4">
                <button id="clear-button" class="w-full bg-slate-500 hover:bg-slate-600 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-transform transform active:scale-95">Clear</button>
                <button id="submit-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-transform transform active:scale-95">Submit</button>
                <button id="towel-button" class="col-span-2 w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform transform active:scale-95 mt-2">Throw in the towel!</button>
            </div>
            
            <div id="message-area" class="text-center mt-2 h-6 text-red-500 font-semibold"></div>
        </main>
    </div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="modal fixed inset-0 bg-black bg-opacity-60 items-center justify-center">
        <div class="bg-white p-8 rounded-2xl shadow-2xl text-center max-w-sm w-full mx-4 transform transition-all scale-95 opacity-0" id="game-over-content">
            <h2 class="text-3xl font-bold mb-2">Game Over!</h2>
            <p class="text-slate-600 mb-4">No more words can be found.</p>
            <div class="bg-slate-100 p-4 rounded-lg mb-6">
                <p class="text-lg text-slate-500">Final Score</p>
                <p id="final-score" class="text-5xl font-bold text-blue-600">0</p>
            </div>
            <button id="play-again-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-transform transform active:scale-95">Play Again</button>
        </div>
    </div>

    <script>
        // --- DOM ELEMENTS ---
        const gameBoard = document.getElementById('game-board');
        const scoreDisplay = document.getElementById('score');
        const currentWordDisplay = document.getElementById('current-word');
        const wordCountDisplay = document.getElementById('word-count');
        const submitButton = document.getElementById('submit-button');
        const clearButton = document.getElementById('clear-button');
        const messageArea = document.getElementById('message-area');
        const gameOverModal = document.getElementById('game-over-modal');
        const gameOverContent = document.getElementById('game-over-content');
        const finalScoreDisplay = document.getElementById('final-score');
        const playAgainButton = document.getElementById('play-again-button');
        const towelButton = document.getElementById('towel-button');
        
        // --- GAME CONSTANTS ---
        const GRID_SIZE = 8;
        const MIN_WORD_LENGTH = 4;
        const BONUS_THRESHOLD = 8;
        const BONUS_MULTIPLIER = 1.5;

        // Difficulty settings that control letter frequency
        const DIFFICULTY_SETTINGS = {
            easy: {
                name: "Easy",
                threshold: 0,
                distribution: "AAAAAAAAABBCCDDDDEEEEEEEEEEEEFFGGGHHIIIIIIIIIJKLLLLMMNNNNNNOOOOOOOOPPQRRRRRRSSSSSTTTTTTUUUUVVWWXYYZ",
                className: "text-green-600"
            },
            medium: {
                name: "Medium",
                threshold: 3, // Starts after 3 words
                distribution: "AAAAAAAAABCCCDDDEEEEEEEEEFFGGGHHIIIIIIIIJKKLLLLMMNNNNNNOOOOOOPPQRRRRRRSSSSSTTTTTTUUUUVVWWXYYZZX",
                className: "text-yellow-600"
            },
            hard: {
                name: "Hard",
                threshold: 8, // Starts after 8 words
                distribution: "AAAAAAABCCCDDEEEEEEFFGGHHIIIIIIIJJKKLLMMNNNNNNOOOOOPPQRRRRRSSSSSSTTTTTUUUVVWWXXYYZZQ",
                className: "text-red-600"
            }
        };

        // Scrabble letter distribution and points
        const SCRABBLE_POINTS = {
            'A': 1, 'B': 3, 'C': 3, 'D': 2, 'E': 1, 'F': 4, 'G': 2, 'H': 4, 'I': 1, 
            'J': 8, 'K': 5, 'L': 1, 'M': 3, 'N': 1, 'O': 1, 'P': 3, 'Q': 10, 'R': 1,
            'S': 1, 'T': 1, 'U': 1, 'V': 4, 'W': 4, 'X': 8, 'Y': 4, 'Z': 10
        };
        
        // --- GAME STATE ---
        let grid = [];
        let score = 0;
        let wordCount = 0;
        let currentSelection = []; // { letter, row, col, element }
        let wordList = new Set();
        let prefixTree = {}; // For efficient end-game check
        let isProcessing = false; // Prevents actions during animations

        // --- DICTIONARY ---
        // The hardcoded dictionary array has been removed to use a fetched list.
        
        // --- INITIALIZATION ---

        async function fetchWordList() {
            // We are now fetching a much larger word list from an online source.
            try {
                messageArea.textContent = "Loading dictionary...";
                const response = await fetch('https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const text = await response.text();
                const words = text.split('\n');

                words.forEach(word => {
                    const upperWord = word.trim().toUpperCase();
                    if (upperWord.length >= MIN_WORD_LENGTH) {
                        wordList.add(upperWord);
                    }
                });
                buildPrefixTree();
                console.log(`Dictionary loaded with ${wordList.size} words.`);
                messageArea.textContent = ""; // Clear loading message
            } catch (error) {
                console.error("Failed to load word list:", error);
                messageArea.textContent = "Error: Could not load dictionary.";
            }
        }
        
        function buildPrefixTree() {
            prefixTree = {};
            for (const word of wordList) {
                let node = prefixTree;
                for (const char of word) {
                    if (!node[char]) {
                        node[char] = {};
                    }
                    node = node[char];
                }
                node.isWord = true;
            }
        }

        function initGame() {
            score = 0;
            wordCount = 0;
            grid = [];
            currentSelection = [];
            isProcessing = false;

            updateScoreboard();
            updateCurrentWordDisplay();
            messageArea.textContent = "";

            // Create initial grid data
            for (let r = 0; r < GRID_SIZE; r++) {
                grid[r] = [];
                for (let c = 0; c < GRID_SIZE; c++) {
                    grid[r][c] = getRandomLetter();
                }
            }
            renderGrid();
            hideGameOverModal();
        }

        // --- GRID & RENDERING ---

        function getRandomLetter() {
            const currentDifficulty = getDifficultyLevel();
            const distribution = currentDifficulty.distribution;
            return distribution[Math.floor(Math.random() * distribution.length)];
        }

        function renderGrid() {
            gameBoard.innerHTML = '';
            grid.forEach((row, r) => {
                row.forEach((letter, c) => {
                    const cell = document.createElement('div');
                    cell.className = 'letter-cell flex items-center justify-center text-lg md:text-2xl font-bold bg-white rounded-md cursor-pointer select-none';
                    cell.textContent = letter;
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    gameBoard.appendChild(cell);
                });
            });
        }
        
        // --- GAME LOGIC ---

        function handleLetterClick(e) {
            if (isProcessing || !(e.target.classList.contains('letter-cell'))) return;

            const row = parseInt(e.target.dataset.row);
            const col = parseInt(e.target.dataset.col);
            const letter = grid[row][col];
            const element = e.target;

            const existingIndex = currentSelection.findIndex(item => item.row === row && item.col === col);
            
            if (existingIndex !== -1) {
                // If it's the *last* selected letter, deselect it
                if (existingIndex === currentSelection.length - 1) {
                    const deselected = currentSelection.pop();
                    deselected.element.classList.remove('selected');
                }
            } else {
                 // Check for adjacency with the last selected letter
                if (currentSelection.length === 0 || isAdjacent(row, col, currentSelection[currentSelection.length - 1])) {
                    currentSelection.push({ letter, row, col, element });
                    element.classList.add('selected');
                }
            }
            updateCurrentWordDisplay();
        }

        function isAdjacent(row, col, lastSelected) {
            const rowDiff = Math.abs(row - lastSelected.row);
            const colDiff = Math.abs(col - lastSelected.col);
            return rowDiff <= 1 && colDiff <= 1;
        }

        function handleSubmit() {
            if (isProcessing || currentSelection.length < MIN_WORD_LENGTH) {
                if(currentSelection.length > 0) showMessage(`Word must be at least ${MIN_WORD_LENGTH} letters.`);
                return;
            }

            const word = currentSelection.map(item => item.letter).join('');
            if (wordList.has(word)) {
                processCorrectWord(word);
            } else {
                showMessage("Not a valid word.");
                clearSelection();
            }
        }
        
        async function processCorrectWord(word) {
            isProcessing = true;
            const wordScore = calculateWordScore(word);
            score += wordScore;
            wordCount++;
            updateScoreboard();
            showMessage(`+${wordScore} for ${word}!`, 'text-green-500');

            // Animate clearing letters
            currentSelection.forEach(item => item.element.classList.add('clearing'));
            await delay(300);

            // Update grid data
            currentSelection.forEach(item => {
                grid[item.row][item.col] = null;
            });
            
            clearSelection();
            await applyGravityAndRefill();
            renderGrid();
            
            if (checkForEndGame()) {
                endGame();
            } else {
                isProcessing = false;
            }
        }
        
        async function applyGravityAndRefill() {
            for (let c = 0; c < GRID_SIZE; c++) {
                let emptyRow = -1;
                // Start from the bottom and move up
                for (let r = GRID_SIZE - 1; r >= 0; r--) {
                    if (grid[r][c] === null && emptyRow === -1) {
                        emptyRow = r;
                    } else if (grid[r][c] !== null && emptyRow !== -1) {
                        // Drop the letter down
                        grid[emptyRow][c] = grid[r][c];
                        grid[r][c] = null;
                        emptyRow--;
                    }
                }
            }
            
            // Refill the top with new letters
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (grid[r][c] === null) {
                        grid[r][c] = getRandomLetter();
                    }
                }
            }
            // A small delay to allow visual separation
            await delay(100);
        }

        function calculateWordScore(word) {
            let baseScore = word.split('').reduce((sum, letter) => sum + SCRABBLE_POINTS[letter], 0);
            if (word.length >= BONUS_THRESHOLD) {
                baseScore = Math.round(baseScore * BONUS_MULTIPLIER);
            }
            return baseScore;
        }

        function clearSelection() {
            currentSelection.forEach(item => item.element.classList.remove('selected'));
            currentSelection = [];
            updateCurrentWordDisplay();
        }

        // --- END GAME LOGIC ---
        function checkForEndGame() {
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (findWordsFromCell(r, c, new Set())) {
                        return false; // Found at least one word, game continues
                    }
                }
            }
            return true; // No words found
        }
        
        function findWordsFromCell(r, c, visited) {
            const path = `${r},${c}`;
            if (visited.has(path)) return false;
            
            visited.add(path);
            
            let found = false;
            function search(row, col, currentWord, currentNode, visitedNodes) {
                if (found) return; // Stop searching if a word is found
                
                // Check bounds and if already visited
                if (row < 0 || row >= GRID_SIZE || col < 0 || col >= GRID_SIZE || visitedNodes.has(`${row},${col}`)) {
                    return;
                }

                const letter = grid[row][col];
                if (!currentNode[letter]) {
                    return; // Not a valid prefix
                }

                const nextNode = currentNode[letter];
                const newWord = currentWord + letter;
                
                if (nextNode.isWord && newWord.length >= MIN_WORD_LENGTH) {
                    console.log("Possible word found:", newWord);
                    found = true;
                    return;
                }

                const newVisited = new Set(visitedNodes);
                newVisited.add(`${row},${col}`);

                // Explore neighbors (8 directions)
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        if (found) return;
                        search(row + dr, col + dc, newWord, nextNode, newVisited);
                    }
                }
            }
            
            search(r, c, '', prefixTree, new Set());
            return found;
        }
        
        function findBestWordOnBoard() {
            let bestWord = null;
            let bestScore = -1;
            let bestPath = [];

            function search(row, col, currentWord, currentNode, visitedNodes, currentPath) {
                if (row < 0 || row >= GRID_SIZE || col < 0 || col >= GRID_SIZE || visitedNodes.has(`${row},${col}`)) {
                    return;
                }

                const letter = grid[row][col];
                if (!currentNode[letter]) {
                    return; // Not a valid prefix
                }

                const nextNode = currentNode[letter];
                const newWord = currentWord + letter;
                const newPath = [...currentPath, { row, col, element: document.querySelector(`[data-row='${row}'][data-col='${col}']`) }];

                if (nextNode.isWord && newWord.length >= MIN_WORD_LENGTH) {
                    const currentScore = calculateWordScore(newWord);
                    if (currentScore > bestScore) {
                        bestScore = currentScore;
                        bestWord = newWord;
                        bestPath = newPath;
                    }
                }

                const newVisited = new Set(visitedNodes);
                newVisited.add(`${row},${col}`);

                // Explore neighbors (8 directions)
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        search(row + dr, col + dc, newWord, nextNode, newVisited, newPath);
                    }
                }
            }

            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    search(r, c, '', prefixTree, new Set(), []);
                }
            }
            return { word: bestWord, score: bestScore, path: bestPath };
        }

        function endGame() {
            isProcessing = true;
            finalScoreDisplay.textContent = score;
            gameOverModal.classList.add('active');
            // Animate the modal content
            setTimeout(() => {
                 gameOverContent.style.transform = 'scale(1)';
                 gameOverContent.style.opacity = '1';
            }, 100);
        }

        function hideGameOverModal() {
            gameOverContent.style.transform = 'scale(0.95)';
            gameOverContent.style.opacity = '0';
            setTimeout(() => {
                gameOverModal.classList.remove('active');
            }, 300);
        }

        // --- UI UPDATES & UTILITIES ---

        function getDifficultyLevel() {
            if (wordCount >= DIFFICULTY_SETTINGS.hard.threshold) {
                return DIFFICULTY_SETTINGS.hard;
            } else if (wordCount >= DIFFICULTY_SETTINGS.medium.threshold) {
                return DIFFICULTY_SETTINGS.medium;
            } else {
                return DIFFICULTY_SETTINGS.easy;
            }
        }

        function updateScoreboard() {
            scoreDisplay.textContent = score;
            wordCountDisplay.textContent = wordCount;
        }

        function updateCurrentWordDisplay() {
            if (currentSelection.length > 0) {
                currentWordDisplay.textContent = currentSelection.map(item => item.letter).join('');
            } else {
                currentWordDisplay.textContent = '-';
            }
        }

        let messageTimeout;
        function showMessage(msg, className = 'text-red-500') {
            clearTimeout(messageTimeout);
            messageArea.textContent = msg;
            messageArea.className = `text-center mt-2 h-6 font-semibold ${className}`;
            messageTimeout = setTimeout(() => {
                messageArea.textContent = "";
            }, 2000);
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // --- EVENT LISTENERS ---
        gameBoard.addEventListener('click', handleLetterClick);
        submitButton.addEventListener('click', handleSubmit);
        clearButton.addEventListener('click', clearSelection);
        playAgainButton.addEventListener('click', initGame);
        towelButton.addEventListener('click', handleTowelThrow);

        // --- START GAME ---
        document.addEventListener('DOMContentLoaded', async () => {
            await fetchWordList();
            initGame();
        });

        async function handleTowelThrow() {
            if (isProcessing) return;
            isProcessing = true;
            showMessage("Finding the best word...", "text-slate-500");
            
            // Use a small delay to allow UI to update before heavy calculation
            await delay(50); 

            const bestWordInfo = findBestWordOnBoard();

            if (bestWordInfo.path.length > 0) {
                showMessage(`Best word: ${bestWordInfo.word} (+${bestWordInfo.score})`, 'text-blue-600');
                bestWordInfo.path.forEach(item => {
                    item.element.classList.add('highlight-best');
                });
                await delay(3000); // Let the user see the word for 3 seconds
            } else {
                showMessage("No words were available!", "text-slate-500");
                await delay(2000);
            }
            
            endGame();
        }

    </script>
</body>
</html>

