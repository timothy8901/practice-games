<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endless Word Twist</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for game tiles and keyboard */
        body {
            font-family: 'Inter', sans-serif;
        }
        .tile {
            /* Use aspect-ratio for responsive square tiles */
            aspect-ratio: 1 / 1;
            width: 100%;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            font-weight: 700;
            text-transform: uppercase;
            user-select: none;
            border: 2px solid #3f3f46; /* border-gray-700 */
            color: #f3f4f6; /* text-gray-100 */
            transition: all 0.3s ease;
        }
        .tile-filled {
            border-color: #52525b; /* border-gray-600 */
            transform: scale(1.02);
        }
        .tile-correct {
            background-color: #16a34a; /* bg-green-600 */
            border-color: #16a34a;
            color: white;
            transform: rotateX(360deg);
            transition: all 0.5s ease;
        }
        .tile-present {
            background-color: #eab308; /* bg-yellow-500 */
            border-color: #eab308;
            color: white;
            transform: rotateX(360deg);
            transition: all 0.5s ease;
        }
        .tile-absent {
            background-color: #3f3f46; /* bg-gray-700 */
            border-color: #3f3f46;
            color: #d1d5db; /* text-gray-300 */
            opacity: 0.8;
            transition: all 0.5s ease;
        }
        .key {
            transition: background-color 0.2s ease, transform 0.1s ease;
        }
        .key:active {
            transform: scale(0.95);
        }
        .key-correct { background-color: #16a34a !important; }
        .key-present { background-color: #eab308 !important; }
        .key-absent { background-color: #3f3f46 !important; }

        /* Animation for solved quadrant */
        @keyframes flashGreen {
            0% { box-shadow: 0 0 0 0px rgba(22, 163, 74, 0.7); }
            50% { box-shadow: 0 0 0 8px rgba(22, 163, 74, 0.3); }
            100% { box-shadow: 0 0 0 0px rgba(22, 163, 74, 0.0); }
        }
        .quad-solved {
            animation: flashGreen 1.5s ease;
        }

        /* Message popup */
        #message-popup {
            transition: opacity 0.3s ease, transform 0.3s ease;
            transform: translateY(-100px);
            opacity: 0;
        }
        #message-popup.show {
            transform: translateY(0);
            opacity: 1;
        }

        /* Game Over screen */
        #game-over-screen {
            transition: opacity 0.5s ease;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 flex flex-col items-center justify-center min-h-screen p-2">

    <!-- Header -->
    <header class="w-full max-w-xl mx-auto flex justify-between items-center p-2 mb-2">
        <h1 class="text-2xl md:text-3xl font-bold text-white">Endless Word Twist</h1>
        <div class="text-right">
            <div class="text-lg font-semibold">Score: <span id="score">0</span></div>
            <div class="text-sm text-gray-400">Guess: <span id="guess-count">1</span> / 8</div>
        </div>
    </header>

    <!-- Game Board -->
    <main id="game-board" class="w-full max-w-xl grid grid-cols-2 gap-2 bg-gray-700 rounded-md overflow-hidden">
        <!-- Quadrant 0 -->
        <div id="quad-0" class="grid grid-cols-5 gap-1 bg-gray-900 p-2"></div>
        <!-- Quadrant 1 -->
        <div id="quad-1" class="grid grid-cols-5 gap-1 bg-gray-900 p-2"></div>
        <!-- Quadrant 2 -->
        <div id="quad-2" class="grid grid-cols-5 gap-1 bg-gray-900 p-2"></div>
        <!-- Quadrant 3 -->
        <div id="quad-3" class="grid grid-cols-5 gap-1 bg-gray-900 p-2"></div>
    </main>

    <!-- Keyboard -->
    <div id="keyboard" class="w-full max-w-xl mx-auto mt-4">
        <!-- Keys will be dynamically generated -->
    </div>

    <!-- Message Popup -->
    <div id="message-popup" class="fixed top-10 p-3 rounded-md shadow-lg bg-red-600 text-white font-semibold">
        Not in word list!
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="fixed inset-0 bg-gray-900 bg-opacity-90 flex flex-col items-center justify-center hidden opacity-0">
        <h2 class="text-4xl font-bold text-white mb-4">Game Over!</h2>
        <p class="text-2xl text-gray-300 mb-6">Final Score: <span id="final-score">0</span></p>
        <button id="play-again-btn" class="px-6 py-3 bg-green-600 text-white text-lg font-bold rounded-md shadow-lg hover:bg-green-700 transition-colors">
            Play Again
        </button>
    </div>

    <script>
        // --- WORD LISTS ---
        // A smaller list for solutions to make the game playable
        const SOLUTION_WORDS = [
            "APPLE", "BEACH", "BRAIN", "BREAD", "BRUSH", "CHAIR", "CHEST", "CHORD", "CLICK", "CLOCK",
            "CLOUD", "DANCE", "DIARY", "DREAM", "DRINK", "EARTH", "FLUTE", "GHOST", "GRAPE", "GREEN",
            "HAPPY", "HEART", "HOUSE", "JUICE", "LIGHT", "LUCKY", "MAGIC", "MONEY", "MUSIC", "NIGHT",
            "OCEAN", "PAPER", "PARTY", "PHONE", "PIZZA", "PLANT", "QUIET", "RAINB", "RIVER", "ROBOT",
            "ROCKY", "SHARK", "SHEEP", "SKATE", "SLEEP", "SMILE", "SOUND", "SPACE", "SPORT", "SQUARE",
            "STARS", "STORM", "SUNNY", "SWEET", "TABLE", "TIGER", "TRAIN", "WATER", "WHALE", "WHITE",
            "WOMAN", "WORLD", "YACHT", "ZEBRA", "ALIVE", "BLEND", "CARRY", "DATES", "EAGLE", "FABLE",
            "GIANT", "HOTEL", "IMAGE", "JOKER", "KOALA", "LEMON", "MANGO", "NINJA", "OLIVE", "PILOT",
            "QUERY", "RADIO", "SUSHI", "TOAST", "ULTRA", "VIDEO", "WAGON", "XENON", "YUMMY", "ZONAL"
        ];

        // VALID_WORDS will be populated from embedded solutions and optionally an external/local wordlist.
        let VALID_WORDS = Array.from(new Set(SOLUTION_WORDS.map(w => w.toUpperCase())));

        // Try to load an external wordlist (remote first, then local files) and merge 5-letter words.
        async function loadWordlist() {
            const candidates = [
                'https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt',
                'wordlist_dwyl.txt',
                'wordlist.txt'
            ];
            for (const url of candidates) {
                try {
                    const resp = await fetch(url);
                    if (!resp.ok) throw new Error('HTTP ' + resp.status);
                    const txt = await resp.text();
                    const words = txt
                        .split(/\r?\n/)
                        .map(w => w.trim().toUpperCase())
                        .filter(Boolean)
                        .filter(w => w.length === 5); // keep 5-letter words for this game
                    if (words.length > 0) {
                        const merged = new Set([...VALID_WORDS, ...words]);
                        VALID_WORDS = Array.from(merged);
                        console.log('Loaded wordlist from', url, 'words:', VALID_WORDS.length);
                        return;
                    }
                } catch (err) {
                    console.warn('Could not load wordlist from', url, err);
                    // try next candidate
                }
            }
            console.warn('No external wordlist loaded; using embedded SOLUTION_WORDS only.');
        }


        // --- GAME STATE ---
        let targetWords = ["", "", "", ""];
        let currentGuessNumber = 1; // Tracks 1 to 10
        let totalScore = 0;
        let currentGuess = "";
        let isGameOver = false;
        let isProcessing = false; // Prevent spamming Enter
        let letterStates = {}; // {'A': 'correct', 'B': 'present', 'C': 'absent'}

        // --- DOM Elements ---
        const quadrants = [
            document.getElementById('quad-0'),
            document.getElementById('quad-1'),
            document.getElementById('quad-2'),
            document.getElementById('quad-3'),
        ];
        const keyboardDiv = document.getElementById('keyboard');
        const scoreEl = document.getElementById('score');
        const guessCountEl = document.getElementById('guess-count');
        const messagePopup = document.getElementById('message-popup');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreEl = document.getElementById('final-score');
        const playAgainBtn = document.getElementById('play-again-btn');

        // --- KEYBOARD ---
        const keyboardLayout = [
            "Q W E R T Y U I O P",
            "A S D F G H J K L",
            "ENTER Z X C V B N M BACK"
        ];

        // --- INITIALIZATION ---
        async function init() {
            // Load dictionary (if available) before starting
            try {
                await loadWordlist();
            } catch (e) {
                console.warn('loadWordlist failed:', e);
            }
            createKeyboard();
            createGrids();
            startGame();
            addEventListeners();
        }

        function createGrids() {
            quadrants.forEach((quad) => {
                quad.innerHTML = '';
                for (let i = 0; i < 8 * 5; i++) { // 8 rows, 5 cols
                    const tile = document.createElement('div');
                    tile.className = 'tile';
                    quad.appendChild(tile);
                }
            });
        }

        function createKeyboard() {
            keyboardLayout.forEach(row => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'flex justify-center gap-1 mb-1';
                row.split(' ').forEach(key => {
                    const keyBtn = document.createElement('button');
                    keyBtn.className = 'key h-12 rounded-md font-bold uppercase p-2 bg-gray-600 text-white flex-1';
                    keyBtn.textContent = key;
                    keyBtn.dataset.key = key;
                    if (key === 'ENTER') keyBtn.classList.add('flex-grow-[1.5]');
                    if (key === 'BACK') keyBtn.classList.add('flex-grow-[1.5]');
                    rowDiv.appendChild(keyBtn);
                });
                keyboardDiv.appendChild(rowDiv);
            });
        }

        function addEventListeners() {
            // On-screen keyboard
            keyboardDiv.addEventListener('click', (e) => {
                if (isProcessing || isGameOver) return;
                const key = e.target.closest('button')?.dataset.key;
                if (!key) return;

                if (key === 'ENTER') {
                    submitGuess();
                } else if (key === 'BACK') {
                    deleteLetter();
                } else {
                    addLetter(key);
                }
            });

            // Physical keyboard
            document.addEventListener('keydown', (e) => {
                if (isProcessing || isGameOver) return;
                if (e.key === 'Enter') {
                    submitGuess();
                } else if (e.key === 'Backspace') {
                    deleteLetter();
                } else if (e.key.match(/^[a-zA-Z]$/)) {
                    addLetter(e.key.toUpperCase());
                }
            });

            // Play Again
            playAgainBtn.addEventListener('click', startGame);
        }

        // --- GAME LOGIC ---
        function startGame() {
            // Reset game state
            targetWords = [getNewWord(), getNewWord(), getNewWord(), getNewWord()];
            currentGuessNumber = 1;
            totalScore = 0;
            currentGuess = "";
            isGameOver = false;
            isProcessing = false;
            letterStates = {};

            // Reset UI
            createGrids(); // Clears all tiles
            updateScoreUI();
            updateGuessCountUI();
            resetKeyboardUI();
            
            // Hide Game Over screen
            gameOverScreen.classList.add('hidden', 'opacity-0');
        }

        function getNewWord() {
            return SOLUTION_WORDS[Math.floor(Math.random() * SOLUTION_WORDS.length)];
        }

        function addLetter(letter) {
            if (currentGuess.length < 5) {
                currentGuess += letter;
                updateCurrentRowUI();
            }
        }

        function deleteLetter() {
            currentGuess = currentGuess.slice(0, -1);
            updateCurrentRowUI();
        }

        function updateCurrentRowUI() {
            // Update the "active" row in all 4 grids
            const guessRowIndex = currentGuessNumber - 1;
            for (let i = 0; i < 4; i++) {
                const quad = quadrants[i];
                for (let j = 0; j < 5; j++) {
                    const tile = quad.children[guessRowIndex * 5 + j];
                    if (tile) {
                        tile.textContent = currentGuess[j] || '';
                        if (currentGuess[j]) {
                            tile.classList.add('tile-filled');
                        } else {
                            tile.classList.remove('tile-filled');
                        }
                    }
                }
            }
        }

        async function submitGuess() {
            if (currentGuess.length !== 5) {
                showMessage("Word must be 5 letters!");
                return;
            }

            if (!VALID_WORDS.includes(currentGuess)) {
                showMessage("Not in word list!");
                return;
            }

            if (isProcessing || isGameOver) return;
            isProcessing = true;

            const guess = currentGuess;
            const guessRow = currentGuessNumber - 1;
            const pointsThisTurn = 11 - currentGuessNumber;
            let solvedQuadrants = [];
            
            const currentLetterStates = {};

            // Process each quadrant
            for (let i = 0; i < 4; i++) {
                const target = targetWords[i];
                const feedback = getGuessFeedback(guess, target);
                
                // Update grid UI
                await updateGridRow(i, guessRow, guess, feedback);
                
                // Check for solve
                if (guess === target) {
                    solvedQuadrants.push(i);
                    totalScore += pointsThisTurn;
                }

                // Update keyboard letter states (global)
                feedback.forEach((status, index) => {
                    const letter = guess[index];
                    updateLetterState(letter, status);
                });
            }

            // Update UI after processing
            updateKeyboardUI();
            updateScoreUI();
            
            // Handle solved quadrants
            if (solvedQuadrants.length > 0) {
                await handleSolvedQuadrants(solvedQuadrants);
            }

            // Move to next guess
            currentGuessNumber++;
            currentGuess = "";
            updateGuessCountUI();

            // Check for game over
            if (currentGuessNumber > 8) {
                endGame();
            }

            isProcessing = false;
        }

        function getGuessFeedback(guess, target) {
            let feedback = Array(5).fill('absent');
            let targetLetters = target.split('');
            let guessLetters = guess.split('');

            // First pass: Find 'correct' (green)
            for (let i = 0; i < 5; i++) {
                if (guessLetters[i] === targetLetters[i]) {
                    feedback[i] = 'correct';
                    targetLetters[i] = null; // Mark as used
                    guessLetters[i] = null; // Mark as used
                }
            }

            // Second pass: Find 'present' (yellow)
            for (let i = 0; i < 5; i++) {
                if (guessLetters[i] !== null) {
                    const indexInTarget = targetLetters.indexOf(guessLetters[i]);
                    if (indexInTarget !== -1) {
                        feedback[i] = 'present';
                        targetLetters[indexInTarget] = null; // Mark as used
                    }
                }
            }
            return feedback;
        }

        async function updateGridRow(quadIndex, rowIndex, guess, feedback) {
            const quad = quadrants[quadIndex];
            const tiles = Array.from(quad.children).slice(rowIndex * 5, rowIndex * 5 + 5);
            
            // Apply flip animation
            for (let i = 0; i < 5; i++) {
                await new Promise(resolve => setTimeout(resolve, 100)); // Stagger flip
                const tile = tiles[i];
                tile.textContent = guess[i];
                tile.classList.remove('tile-filled');
                if (feedback[i] === 'correct') {
                    tile.classList.add('tile-correct');
                } else if (feedback[i] === 'present') {
                    tile.classList.add('tile-present');
                } else {
                    tile.classList.add('tile-absent');
                }
            }
        }

        async function handleSolvedQuadrants(quadIndexes) {
            // Flash green border
            for (const i of quadIndexes) {
                quadrants[i].classList.add('quad-solved');
            }

            // Wait for animation
            await new Promise(resolve => setTimeout(resolve, 1500));

            // Reset solved quadrants
            for (const i of quadIndexes) {
                quadrants[i].classList.remove('quad-solved');
                targetWords[i] = getNewWord(); // Get new word
                clearGridUI(i); // Clear the UI for this grid
            }
        }

        function clearGridUI(quadIndex) {
            const quad = quadrants[quadIndex];
            const tiles = quad.children;
            for (let i = 0; i < tiles.length; i++) {
                tiles[i].textContent = '';
                tiles[i].className = 'tile'; // Reset to default state
            }
        }

        function endGame() {
            isGameOver = true;
            finalScoreEl.textContent = totalScore;
            gameOverScreen.classList.remove('hidden');
            // Use timeout to allow a DOM repaint, then trigger transition
            setTimeout(() => {
                gameOverScreen.classList.remove('opacity-0');
            }, 10);
        }

        // --- UI UPDATES ---
        function updateScoreUI() {
            scoreEl.textContent = totalScore;
        }

        function updateGuessCountUI() {
            guessCountEl.textContent = Math.min(currentGuessNumber, 8);
        }

        function updateLetterState(letter, status) {
            const current = letterStates[letter];
            // Priority: correct > present > absent
            if (current === 'correct') return;
            if (current === 'present' && status === 'absent') return;
            letterStates[letter] = status;
        }

        function resetKeyboardUI() {
            keyboardDiv.querySelectorAll('button').forEach(btn => {
                btn.classList.remove('key-correct', 'key-present', 'key-absent');
            });
        }

        function updateKeyboardUI() {
            keyboardDiv.querySelectorAll('button').forEach(btn => {
                const key = btn.dataset.key;
                if (letterStates[key]) {
                    btn.classList.remove('key-correct', 'key-present', 'key-absent');
                    btn.classList.add(`key-${letterStates[key]}`);
                }
            });
        }

        function showMessage(msg) {
            messagePopup.textContent = msg;
            messagePopup.classList.add('show');
            setTimeout(() => {
                messagePopup.classList.remove('show');
            }, 2000);
        }

        // --- Start the game ---
        init();
    </script>
</body>
</html>


